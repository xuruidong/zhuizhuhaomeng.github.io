---
layout: post
title: "strncpy 到底是怎么工作的"
description: "strncpy 到底是怎么工作的"
date: 2024-01-23
tags: [strncpy, memset, stpncpy, mempcpy]
---

很多面谈题喜欢让人回答如何才能安全拷贝字符串。要比较 `strcpy` 和 `strncpy` 的区别。
事实上，大多数的面试官是不知道 `strncpy` 具体是怎么实现，有什么副作用的。

我们通过 `man strncpy` 可以清楚的看到，`strncpy` 其实执行了一个 `bzero` 的动作，也就是将
目标地址空间的内存清 0 了。

```C
char *
strncpy(char *restrict dst, const char *restrict src, size_t sz)
{
    stpncpy(dst, src, sz);
    return dst;
}

char *
stpncpy(char *restrict dst, const char *restrict src, size_t sz)
{
    bzero(dst, sz);
    return mempcpy(dst, src, strnlen(src, sz));
}
```

上面有个比较不常见的函数 `mempcpy`。还是通过 man 手册，我们知道该还是基本等同于 `memcpy`，
只不过返回值指向了拷贝的数据的末尾的后一个字节的。这种返回值方便级联操作，不需要自己再执行类似
`dst += len` 的操作。

```man
The  mempcpy()  function  is nearly identical to the memcpy(3) function.  It copies n bytes from the object beginning at src into the object
pointed to by dest.  But instead of returning the value of dest it returns a pointer to the byte following the last written byte.
```

当然，面试的重点在于知道 `strncpy` 拷贝 `n` 个字节, 如果源字符串超过 `n` 字节，那么拷贝的内容是不会以 `\0` 结尾的。

但是，我想问一个问题： 如果源字符串中间包含 `\0`, 那么拷贝是否会在中间的 `\0` 结尾呢？

比如字符串 "Hello world!\0Welcome to the hell of strncpy!"

如果你认真阅读了上面的参考实现，那么你应该知道是会把中间的 `\0` 以及 `\0` 之后的字符给拷贝过去的。

另外一个问题是 `strncpy` 是否高效呢？ 其实因为有了 `bzero` 的操作，这个并不见得高效。比如你的 `dst` 空间是
10M， 你的 `src` 字符串一般情况下只有 100 字节左右，但是少数情况下可能很长。那么使用 strncpy 显然不是一个好的选择。

所以，面试官再提这种问题，就好好的教育教育他吧！
